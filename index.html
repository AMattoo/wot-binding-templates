<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Web of Things (WoT) Protocol Binding Templates</title>
    <script class="remove" async="" src="https://www.w3.org/Tools/respec/respec-w3c-common"></script>
    <script class="remove">
          var respecConfig = {
              specStatus:     "ED"
            , processVersion: 2017
            , shortName:      "wot-binding-templates"
            , copyrightStart: 2017
            , wg:             "Web of Things Working Group"
            , wgURI:          "https://www.w3.org/WoT/WG/"
            , wgPublicList:   "public-wot-wg"
            , edDraftURI:     "https://w3c.github.io/wot-binding-templates/"
            , githubAPI:      "https://api.github.com/repos/w3c/wot-binding-templates"
            , issueBase:      "https://www.github.com/w3c/wot-binding-templates/issues"
            , editors: [
                {
                  name:       "Michael Koster"
                , w3cid:      "00000"
                , company:    "SmartThings"
                , companyURL: "https://www.smartthings.com/"
                }
              ]
            , otherLinks: [
                {
                  key: "Contributors"
                , data: [
                    {
                      value: "In the GitHub repository"
                    , href: "https://github.com/w3c/wot-architecture/graphs/contributors"
                    }
                  ]
                }
              , {
                  key: "Repository",
                  data: [
                    {
                      value: "We are on GitHub",
                      href: "https://github.com/w3c/wot-binding-templates/"
                    }
                  , {
                      value: "File a bug",
                      href: "https://github.com/w3c/wot-binding-templates/issues"
                    }
                  ]
                }
              ]
            , localBiblio: {
                "WOT-TD" : {
                  title: "Web of Things (WoT) Thing Description"
                , href: "https://w3c.github.io/wot-thing-description/"
                , authors:  [
                    "Sebastian Kaebisch",
                    "Takuki Kamiya"
                  ]
                , publisher: "W3C"
                , date: "09 September 2018"
                }
              , "CoRE-RD" : {
                  href: "https://tools.ietf.org/html/draft-ietf-core-resource-directory-11"
                , title: "CoRE Resource Directory"
                , status:    "Internet-Draft"
                , publisher: "IETF"
                , date: "03 July 2017"
                }
              }
            };
    </script>
  </head>
  <body>

    <section id="abstract">
      <p>
        W3C Web of Things enables applications to interact with and orchestrate
        connected Things at Web scale. The standardized abstract interaction
        model exposed by the WoT Thing Description enables applications to scale and
        evolve independently of the individual Things.
      </p>
      <p>
        Many network-level protocols and standards for connected Things have
        already been developed, and have millions of devices deployed in the
        field today. These standards are converging on a common set of transport
        protocols and transfer layers, but each has peculiar content formats,
        payload schemas, and data types.
      </p>
      <p>
        Despite using unique formats and data models, the high-level interactions
        exposed by most connected things can be modeled using the Property, Action,
        and Event interaction patterns of the WoT Thing Description.
      </p>
      <p>
        Protocol Binding Templates enable a Thing Description to be adapted to
        the specific protocol usage across the different standards. This is done
        through additional descriptive vocabulary that is used in the
        Thing Description.
      </p>
      <p>
        This document describes the initial set of design pattern and vocabulary
        extensions to the WoT Thing Description that make up the Protocol Binding
        Templates. It is expected over time that additional protocols will be
        accommodated by further extending the Binding Templates, adding new
        vocabulary and new design patterns.
      </p>
    </section>


    <section id="sotd">
      <p class="ednote" title="The W3C WoT WG is asking for feedback">
        Please contribute to this draft using the
        <a href="https://github.com/w3c/wot-binding-templates/issues">GitHub Issue</a>
        feature of the <a href="https://github.com/w3c/wot-binding-templates/">
        WoT Protocol Binding Templates</a> repository.
        For feedback on security and privacy considerations, please use the
        <a href="https://github.com/w3c/wot-security/issues">WoT Security and Privacy</a>
        Issues, as they are cross-cutting over all our documents.
      </p>
    </section>


    <section>
      <h1>Introduction</h1>
      <p>
        Protocol Binding Templates consist of reusable vocabulary and design
        pattern extensions to the WoT Thing Description format that enable an
        application client to interact, using a consistent interaction model,
        with Things that expose diverse protocols and protocol usage.
      </p>

      <section>
        <h2>Protocol Adaptation</h2>
        <p>
          Protocol Binding Templates enable clients to adapt to the underlying
          protocol and network-facing API constructions. Once the base protocol
          (e.g., HTTP, CoAP, MQTT, etc.) is identified, the following adaptions
          specifiy the particular use within the given Platform.
        </p>
        <p class="ednote" title="Additional Protocol Bindings">
          This document contains examples of Protocol Bindings for HTTP, CoAP,
          and MQTT. Other prococols may be added, following the same design style,
          and using payload mappings that can be expressed as JSON compatible
          entities. Future extensions to other payload definition formats  are
          also contemplated.
        </p>

        <section>
          <h3>Protocol Methods and Options</h3>
          <p>
            Most protocols have a relatively small set of methods that define
            the message type, the semantic intention of the message. As a starting
            point, a superset of REST and PubSub can cover most standard
            communication patterns. Common methods are GET, PUT, POST, DELETE,
            PUBLISH, and SUBSCRIBE.
          </p>
          <p>
            The protocol methods are mapped to the abstract WoT Interaction verbs
            <code>readproperty</code>, <code>writeproperty</code>,
            <code>observeproperty</code>, <code>invokeaction</code>,
            <code>subscribeevent</code>, <code>unsubscribeevent</code>.
            <!-- modifyAction, cancelAction is still undefined -->
          </p>
          <p>
            Possible protocol options are also specified in the Protocol Binding.
            They are used to select transfer modes, to request notifications from
            observable resources, or otherwise extend the semantics of the protocol
            methods.
          </p>
        </section>

        <section>
          <h3>Media Types</h3>
          <p>
            Maximum use should be made of IANA-registered Media Types (e.g.,
            <code>application/json</code>) in order to decouple applications from
            connected Things. Standard bridges and translations from proprietary
            formats to Web-friendly languages such as JSON and XML are part of the
            adaptation needed.
          </p>
          <p>
            WoT Protocol Bindings depend on consistent use of Media Types for
            customization of the upper layers.
          </p>
        </section>

        <section>
          <h3>Payload Structure</h3>
          <p>
            Data serialized to a standard Media Type still remains in a structure
            specific to the Platform data model and needs to be understood by
            clients (cf. various types of JSON documents).
          </p>
          <p>
            The data definition language of <code>DataSchema</code>
            elements, described in [TD], allows for describing arbitrary
            structures by nesting of arrays and objects. Constants and
            variable specifications may be intermixed.
          </p>
        </section>

        <section>
          <h3>Data Types and Value Constraints</h3>
          <p>
            Simple data types and value constraints are currently used in a layered
            and descriptive way in WoT Thing Description. Additional forms of
            constraints are available to help adapt to the underlying data types.
            A Platform-specific 8-bit unsigned integer, for instance, can be defined
            as Integer with a minimum of 0 and maximum of 255; the system-specific
            representation (e.g., exact number of bits) on server and client is not
            relevant for interoperability.
          </p>
        </section>
      </section>
    </section>

    <section id="binding-overview" class="informative">
      <h1>Protocol Binding Templates Overview</h1>
      <p>
        This section describes the mechanisms of protocol binding templates with
        examples.
      </p>

      <section id="Data Schema">
        <h2>Data Schema</h2>
        <p>
          A data schema describes the payload structure and included
          data items that are passed between client and server during interactions.
        </p>

        <section id="payload-structure">
          <h2>Payload Structure</h2>
          <p>
            Payload Structure is determined by <code>DataSchema</code> elements of a Thing Description.
            DataSchema elements are indicated by the <code>type</code> keyword in an Interaction Description with associated
            JSON Schema validation keywords. The additional keywords <code>input</code> and
            <code>output</code> are used to provide two different schemas when data
            might be exchanged in both directions, such as in the case of invoking an Action
            when status information is returned.
          </p>
          <p>
            In addition to the example pattern in [[!WOT-TD]] of an object with name/value
            constructs or simple arrays, Protocol Bindings for existing standards
            may require nested arrays and objects, and some constant values to
            be specified.
          </p>
          <p>
            For example, a simple payload structure may use a map:
          </p>

          <p>
            <pre class="example" title="Simple Payload Structure">
              {
                "level": 50,
                "time": 10
              }
            </pre>

          <p>
            SenML might use the following construct:
          </p>

          <pre class="example" title="SenML Example">
            [
              {
                "bn": "/example/light/"
              },
              {
                "n": "level",
                "v": 50
              },
              {
                "n": "time",
                "v": 10
              }
            ]
          </pre>

          <p>
            A Batch Collection according to OCF may be structured like this:
          </p>

          <pre class="example" title="OCF Batch Example">
            [
              {
                "href": "/example/light/level",
                "rep": {
                  "dimming": 50
                }
              },
              {
                "href": "/example/light/time",
                "rep": {
                  "ramptime": 10
                }
              }
            ]
          </pre>

          <p>
            And an IPSO Smart Object on LWM2M might look like the following:
          </p>

          <pre class="example" title="IPSO/LWM2M Example">
            {
              "bn": "/3001/0/",
              "e": [
                {
                  "n": "5044",
                  "v": 0.5
                },
                {
                  "n": "5002",
                  "v": 10.0
                }
              ]
            }
          </pre>

          <p>
            The Protocol Binding template for each of these payloads will be
            structured according to the desired payload structure.
          </p>

          <p>
            For the Simple Payload in Example 1 above, the <code>DataSchema</code> element would
            be structured as follows:
          </p>

          <pre class="example" title="DataSchema for Simple JSON Object Payload">
            {
              "type": "object",
              "properties": {
                "level": {
                  "@type": ["iot:LevelData"],
                  "type": "integer",
                  "minimum": 0,
                  "maximum": 255
                },
                "time": {
                  "@type": ["iot:TransitionTimeData"],
                  "type": "integer",
                  "minimum": 0,
                  "maximum": 65535
                }
              }
            }
          </pre>

          <p>
            For the SenML Payload in Example 2 above, the <code>DataSchema</code> element would
            be structured as follows:
          </p>

          <pre class="example" title="DataSchema for SenML Payload">
            {
              "type": "array",
              "items": [
                {
                  "type": "object",
                  "properties": {
                    "bn": {
                      "type": "string",
                      "const": "example/light"
                    }
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "n": {
                      "type": "string",
                      "const": "level"
                    },
                    "v": {
                      "@type": ["iot:LevelData"],
                      "type": "integer",
                      "minimum": 0,
                      "maximum": 255
                    }
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "n": {
                      "type": "string",
                      "const": "time"
                    },
                    "v": {
                      "@type": ["iot:TransitionTimeData"],
                      "type": "integer",
                      "minimum": 0,
                      "maximum": 65535
                    }
                  }
                }
              ]
            }
          </pre>

          <p>
            For the OCF Batch Payload in Example 3 above, the <code>DataSchema</code> element would
            be structured as follows:
          </p>

          <pre class="example" title="DataSchema for OCF Batch Payload">
            {
              "type": "array",
              "items": [
                {
                  "type": "object",
                  "properties": {
                    "href": {
                      "type": "string",
                      "const": "/light/level"
                    },
                    "rep": {
                      "type": "object",
                      "properties": {
                        "dimming": {
                          "@type": ["iot:LevelData"],
                          "type": "integer",
                          "minimum": 0,
                          "maximum": 255
                        }
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "href": {
                      "type": "string",
                      "const": "/light/time"
                    },
                    "rep": {
                      "type": "object",
                      "properties": {
                        "ramptime": {
                          "@type": ["iot:TransitionTimeData"],
                          "type":"integer",
                          "minimum": 0,
                          "maximum": 65535
                        }
                      }
                    }
                  }
                }
              ]
            }
          </pre>

          <p>
            For the IPSO/LWM2M Payload in Example 4 above, the <code>DataSchema</code> element would
            be structured as follows:
          </p>

          <pre class="example" title="DataSchema for IPSO/LWM2M Payload">
            {
              "type": "object",
              "properties": {
                "bn": {
                  "type": "string",
                  "const": "/3001/0/"
                },
                "e": {
                  "type": "array",
                  "items": [
                    {
                      "type": "object",
                      "properties": {
                        "n": {
                          "type": "string",
                          "const": "5044"
                        },
                        "v": {
                          "@type": ["iot:LevelData"],
                          "type": "number",
                          "minimum": 0.0,
                          "maximum": 1.0
                        }
                      }
                    },
                    {
                      "type": "object",
                      "Properties": {
                        "n": {
                          "type": "string",
                          "const": "5002"
                        },
                        "v": {
                          "@type": ["iot:TransitionTimeData"],
                          "type": "number",
                          "minimum": 0.0,
                          "maximum": 6553.5
                        }
                      }
                    }
                  ]
                }
              }
            }
          </pre>
        </section>

        <section id="data-types-constraints">
          <h2>Data Types and value constraints</h2>
          <p>
            Note that in Example 5 above, the values are floating point while the
            other examples have integer values. It is up to the client to adapt to
            the range and type as well as the engineering units provided.
          </p>
        </section>

      </section>

      <section id="form-element">
        <h2>Forms Element</h2>
        <p>
          The form elements contain the URI pointing to an instance of the interaction
          and descriptions of the protocol settings and options expected to be used when
          between the client and server for the interaction.
        </p>

        <section id="relation-types">
          <h2>Relation Types</h2>
          <p>
            Form Relation Types describe the expected result of performing the operation
            described by the form.
          </p>
          <p>
            For example, the Property interaction allows read and write operations. The
            protocol binding may contain a form for the read operation and a different
            form for the write operation. The value of the "rel" attribute of the form
            indicates which form is which and allows the client to select the correct
            form for the operation required.
          </p>

          <pre class="example" title="Form Relation Types">
            "rel": "readproperty"
            "rel": "writeproperty"
          </pre>

          <p>
            The vocabulary in section 5 lists the recommended set of form relations,
            and the full TD examples in section 6 contain example uses of form relation types.
          </p>
        </section>

        <section id="media-types">
          <h2>Media Types</h2>
          <p>
            Media Types define the serialization details and other rules for processing
            the payloads. The media type is used to select a serializer/deserializer
            and to select an additional set of rules and constraints for the protocol
            driver.
          </p>
          <p>
            For example, the mediaType "application/ocf+cbor" indicates that CBOR
            serialization is used, but also that OCF rules and namespaces
            apply to the processing of the representations.
          </p>
          <p>
            Additionally, there may be a profile which points to a URI for
            further description, for example a form with
            profile=http://iotschema.org/protocols/ipso.jsonld indicates that the
            target representation follows a set of additional encoding rules and
            constraints which are further defined at the URI by the profile
            attribute's value.
          </p>
          <p>
            Some special protocol drivers may be invoked by using a non-registered
            media type (e.g., <code>x-<echonet></code>) along with a custom URI scheme and its own
            set of protocol methods and options defined for that URI scheme.
          </p>
        </section>

        <section id="protocol-methods-options">
          <h2>Protocol Methods and Options</h2>
          <p>
            Each target protocol may specify different method names for similar
            methods, and there may be semantic differences between similar methods of
            different protocols. Additionally, will use different methods
            for mapping to a particular WoT Interaction type. For example, POST may
            be used for setting a property value in one protocol, while PUT may be
            used in another. For these reasons, we require the ability to specify
            which method to use for a particular interaction. We also will provide
            vocabulary to differentiate between methods of different protocols.
          </p>
          <p>
            The W3C RDF vocabulary for HTTP [ref] is used to identify the methods
            and options specified in the HTTP protocol bindings.
          </p>
          <p>
            For the sake of consistency, we will use the same ontology design pattern
            to derive a vocabulary for each target protocol, e.g. CoAP, MQTT.
          </p>

          <p>
            The example below shows some method definitions for various protocols.
          </p>

          <pre class="example" title="Vocabulary Example for Methods">
            "http:methodName": "GET"

            "mqtt:commandCode": 8

            "coap:methodCode": 1
          </pre>

          <p>
            Header options in HTTP, CoAP, MQTT sometimes must be included in a
            protocol binding in order to successfully interact with the underlying
            protocol. The example below shows the structure of the definition for
            http header options, according to the W3C HTTP Vocabulary in RDF.
          </p>

          <pre class="example" title="HTTP Vocabulary Example for Header Options">
            "http:headers":
              [
                {
                  "http:fieldName": "Accept",
                  "http:fieldValue": "application/json"
                },
                {
                  "http:fieldName": "Transfer-Encoding",
                  "http:fieldValue": "chunked"
                }
              ]
          </pre>
          <p>
            Note: different forms in a binding may need different header constructions,
            therefore the <code>headers</code> construct is an extension of the TD "form" element.
          </p>
          <p>
            Protocols may have defined sub-protocols that can be used for some interaction
            types. For example, to recieve asynchronous notifications using http, some
            servers may support long polling, EventSource, or a simple non-multiplexed
            websocket protocol.

            The "subProtocol" item may be defined in a form instance to indicate the
            use of one of these protocols, for example:
            <pre class="example" title="subProtocol">
              {
              "subProtocol": "LongPoll"
              }
            </pre>

            </thead>
          </p>


        </section>

    </section>


    <section id="Interaction Types" class="informative">
      <h1>Interaction Patterns</h1>
      <p>
        This section describes unique aspects of protocol bindings for the three
        WoT Interaction Patterns.
      </p>

      <section id="property-bindings">
        <h2>Bindings for Properties</h2>
        <p>
          This section describes unique aspects of protocol bindings for
          WoT Property interactions.
        </p>
        <p>
          The abstract operations exposed for Properties are <code>readproperty</code>,
          <code>writeproperty</code>, and <code>observeproperty</code>.
          These are mapped by using form relations that describe how
          the abstract operation is performed, resulting in a semantic interpretation similar to
          HTML form submission.
        </p>
        <pre class="example" title="Example use of form relation for Property">
          {
            "rel": "writeproperty",
            "href": "/example/level",
            "http:methodName": "POST"
          }
        </pre>
        <p>
          The form element in the example above conveys the statement: <i>"To do a <code>writeproperty</code> of the subject Property (context of the form),
          perform a <code>POST</code> on the resource at the target URI <code>/example/level</code>."</i>
        </p>
        <p>
          Properties may be observable, defined by the TD keyword "observable".
          If there is an observe form and a retrieve form, the observe form may be
          indicated by including rel=observeproperty in the form. The observe form may
          also specify header options to use, for example CoAP observe option=0
          in the header to start observation.
        </p>
      </section>

      <section id="action-bindings" class="informative">
        <h2>Bindings for Actions</h2>
        <p>
          This section describes unique aspects of protocol bindings for WoT
          Action type interactions.
        </p>
        <p>
          The abstract method on Actions is invokeaction. In the same way that
          the abstract methods on properties are
          mapped using form relations, the abstract methods of actions are also
          mapped.
        </p>
        <pre class="example" title="Example use of form relation for Action">
          {
            "rel": "invokeaction",
            "href": "/example/levelaction",
            "http:methodName": "POST"
          }
        </pre>
        <p>
          The form element in the example above conveys the statement: <i>"To do an <code>invokeaction</code> of the subject Action (context of the form),
          perform a <code>POST</code> on the resource at the target URI <code>/example/levelaction</code>."</i>
        </p>
      </section>

      <section id="event-bindings" class="informative">
        <h2>Bindings for Events</h2>
        <p>
          This section describes unique aspects of protocol bindings for WoT
          Event type interactions.
        </p>
        <p>
          The abstract methods on Events are subscribeevent and unsubscribeevent.
          The subscribeevent operation returns a location or resource URI from which
          events may be obtained, either by observation or some other method,
          depending on the transfer protocol.
        </p>
        <p>
          The binding for Events allows pre-defined URIs to observable resources,
          or pubsub topica encoded in URI.
        </p>
        <p>
          If the binding offers a subscription, there will be a form with
          rel=subscribeevent
        </p>
        <p>
          If the binding offers an observable Event resource from which events are
          obtained, there will be a form which describes the required transfer layer
          operation, for example CoAP Observe or HTTP Long Polling.
        </p>
        <pre class="example" title="Example use of form relation for Events">
          {
            "rel": "subscribeevent",
            "href": "mqtt://wot.example.com/levelevent",
            "mqtt:methodCode": 8
          }
        </pre>
        <p>
          The form element in the example above conveys the statement: <i>"To do an <code>subscribeevent</code> of the subject Event (context of the form),
          perform an <code>MQTT SUBSCRIBE</code> (code 8) on the topic <code>/levelevent</code> on the broker at <code>wot.example.com</code> using the default MQTT port."</i>
        </p>
      </section>

    </section>

    <section id="processing-model" class="informative">
      <h1>Processing Model and Runtime</h1>
      <p>
        This section describes the processing model for Protocol Bindings with
        respect to the abstract WoT Interactions provided by the Scripting API.
      </p>
      <p>
        <code>DataSchema</code> elements (see Section 2.1) are processed, and
        value scaling is performed, in the application library or adaptation layer.
      </p>
      <p>
        Form elements that specify href, method, options, and mediaType are
        processed in a driver context which is isolated from the application.
      </p>
      <p>
        The application, or a protocol adaptation layer, constructs an instance of
        the appropriate DataSchema element
        and sends it along with the selected form contents to the protocol driver
        or, in the case of get, receives a payload form the protocol driver and
        uses the appropriate <code>DataSchema</code> element to extract the field values of interest.
      </p>
      <p>
        The separation of execution context between the application and the protocol
        driver enables isolation of fault domains and isolation of security domains.
      </p>
      <p class="ednote" title="Multiple Security Bindings">
        Additional information in the Thing Description may be considered part
        of the Protocol Binding, relating to security protocols. There is currently
        a single declaration of security bindings for each TD instance, with
        no defined way to indicate a different security protocol for each form
        element, which may specify a different transfer protocol.
      </p>
      <p>
        Protocol Bindings may be used by proxies, where a Consumed Thing has its
        Protocol Binding, and the corresponding Exposed Thing may have a different
        Protocol Binding.
      </p>
    </section>

    </section>

    <section id="vocabulary" class="informative">
      <h1>Vocabulary</h1>
        <p>
          This section summerizes the vocabulary used for protocol binding templates.
          The vocabulary is defined in other documents, in particular the WoT Thing Description [[!WOT-TD]]
        </p>
        <section>
          <h2><code>DataSchema</code> Vocabulary</h2>
            <p>
              <code>DataSchema</code> elements describe the structure of the payload.
              The <code>DataSchema</code> class and vocabulary is defined in [[!WOT-TD]].
              Properties and Events directly implement the <code>DataSchema</code> class
              (i.e., they contain the corresponding fields such as <code>type</code>),
              which describes the data transfer in either direction.
              Actions may define an <code>input</code> data schema for actuation data being sent to the Action
              and/or an <code>output</code> data schema for result or status data being returned from
              the Action.
            </p>
        </section>

        <section>
          <h2>Form Relation Type Vocabulary</h2>
            <p>
              Each interaction pattern has associated form relation types
              that are used to select the form element corresponding to the intended interaction,
              reading a Property vs writing a Property vs observing a Property.
            </p>
          <section>
            <h3>Property Forms</h3>
              <p>
                Properties provide "read" and, optionally, "write"
                operations, which map to GET and PUT/POST of a REST API.
                Properties may also by observed, though some properties may not be observable.
              </p>
              <table class="def">
                <thead>
                  <tr>
                    <th><code>rel</code> Term</th>
                    <th>Description</th>
                    <th>Type</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>readproperty</code></td>
                    <td>Read a Property.</td>
                    <td><a href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#string"><code>string</code></a></td>
                  </tr>
                  <tr>
                    <td><code>writeproperty</code></td>
                    <td>Write a Property. Requires <code>writable</code> to be set to <code>true</code>.</td>
                    <td><a href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#string"><code>string</code></a></td>
                  </tr>
                  <tr>
                    <td><code>observeproperty</code></td>
                    <td>Observe a Property. Requires <code>observable</code> to be set to <code>true</code>.</td>
                    <td><a href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#string"><code>string</code></a></td>
                  </tr>
                </tbody>
              </table>
            </section>

          <section>
            <h3>Action Forms</h3>
              <p>
                Actions only provide "invoke" operations.
                For completeness, there is also a form relation type defined.
              </p>
              <table class="def">
                <thead>
                  <tr>
                    <th><code>rel</code> Term</th>
                    <th>Description</th>
                    <th>Type</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>invokeaction</code></td>
                    <td>Invoke an Action.</td>
                    <td><a href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#string"><code>string</code></a></td>
                  </tr>
                </tbody>
              </table>
          </section>

          <section>
            <h3>Event Forms</h3>
              <p>
                Events describe subscription endpoints from which to event instances can be received.
              </p>
              <table class="def">
                <thead>
                  <tr>
                    <th><code>rel</code> Term</th>
                    <th>Description</th>
                    <th>Type</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>subscribeevent</code></td>
                    <td>Subscribe to an Event.</td>
                    <td><a href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#string"><code>string</code></a></td>
                  </tr>
                  <tr>
                    <td><code>unsubscribeevent</code></td>
                    <td>Unsubscribe drom an Event.</td>
                    <td><a href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#string"><code>string</code></a></td>
                  </tr>
                </tbody>
              </table>
            </section>
          </section>

          <section>
          <h2>Protocol Vocabulary</h2>
            <p>
              Extensions to the TD core vocabulary can inform the client about
              protocol-specific message configurations such as methods, options, and status codes.
              The vocabulary comes from existing Linked Data vocabulary such as the HTTP Vocabulary in RDF 1.0 [[?HTTP-in-RDF10]].
            </p>
            <p class="ednote" title="Protocol Vocabulary Definitions">
              The WoT Working Group is investigating good ways to also provide COAP and MQTT Vocabulary in RDF.
              If the WG will publish corresponding WG Notes is still subject to discussion.
            </p>
            
            <section>
              <h3>HTTP Vocabulary</h3>
              <table class="def">
                <thead>
                  <tr>
                    <th>Field Name</th>
                    <th>Description</th>
                    <th>Mandatory</th>
                    <th>Default value</th>
                    <th>Type</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>http:methodName</code></td>
                    <td>HTTP method name (Literal).</td>
                    <td>no</td>
                    <td>
                      <p><code>readproperty</code>: <code>"GET"</code></p>
                      <p><code>writeproperty</code>: <code>"PUT"</code></p>
                      <p><code>invokeaction</code>: <code>"POST"</code></p>
                    </td>
                    <td>
                      <a href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#string"><code>string</code></a>
                      <p>(one of <code>"GET"</code>, <code>"PUT"</code>, <code>"POST"</code>, <code>"DELETE"</code>, <code>"PATCH"</code>)</p>
                    </td>
                  </tr>
                  <tr>
                    <td><code>http:headers</code></td>
                    <td>HTTP headers sent with the message.</td>
                    <td>no</td>
                    <td>.</td>
                    <td>
                      array of <a href="https://www.w3.org/TR/HTTP-in-RDF10/#MessageHeaderClass"><code>http:MessageHeader</code></a>
                    </td>
                  </tr>
                  <tr>
                    <td><code>http:fieldName</code></td>
                    <td>Header name (Literal), e.g., <code>"Accept"</code>, <code>"Transfer-Encoding"</code>.</td>
                    <td>yes (within <code>http:headers</code>)</td>
                    <td>.</td>
                    <td>
                      <a href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#string"><code>string</code></a>
                    </td>
                  </tr>
                  <tr>
                    <td><code>http:fieldValue</code></td>
                    <td>Header value (Literal).</td>
                    <td>yes (within <code>http:headers</code>)</td>
                    <td>.</td>
                    <td>
                      <a href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#string"><code>string</code></a>
                    </td>
                  </tr>
                </tbody>
              </table>
            </section>
            
            <section>
              <h3>CoAP Vocabulary</h3>
              <table class="def">
                <thead>
                  <tr>
                    <th>Field Name</th>
                    <th>Description</th>
                    <th>Mandatory</th>
                    <th>Default value</th>
                    <th>Type</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>coap:methodCode</code></td>
                    <td>CoAP method code (Literal).</td>
                    <td>no</td>
                    <td>
                      <p><code>readproperty</code>: <code>1</code></p>
                      <p><code>writeproperty</code>: <code>3</code></p>
                      <p><code>observeproperty</code>: <code>1</code></p>
                      <p><code>invokeaction</code>: <code>2</code></p>
                    </td>
                    <td>
                      <a href="https://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#unsignedByte"><code>unsignedByte</code></a>
                      <p>(one of <code>1</code> (GET), <code>2</code> (POST), <code>3</code> (PUT), <code>4</code> (DELETE), <code>5</code> (FETCH), <code>6</code> (PATCH), <code>7</code> (iPATCH))</p>
                    </td>
                  </tr>
                  <tr>
                    <td><code>coap:options</code></td>
                    <td>CoAP options sent with the message, e.g., <code>[ { "coap:optionNumber": 6, "coap:optionValue": 49 } ]</code>.</td>
                    <td>no</td>
                    <td>.</td>
                    <td>
                      array of <code>coap:MessageOption</code>
                    </td>
                  </tr>
                  <tr>
                    <td><code>coap:optionNumber</code></td>
                    <td>Option number (Literal), see <a href="https://www.iana.org/assignments/core-parameters/core-parameters.xhtml#option-numbers">CoRE Parameters</a>.</td>
                    <td>yes (within <code>coap:options</code>)</td>
                    <td>.</td>
                    <td>
                      <a href="https://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#unsignedShort"><code>unsignedShort</code></a>
                    </td>
                  </tr>
                  <tr>
                    <td><code>coap:optionValue</code></td>
                    <td>Header value (Literal).</td>
                    <td>yes (within <code>coap:options</code>)</td>
                    <td>.</td>
                    <td>
                      <a href="https://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#anyType"><code>anyType</code></a>
                    </td>
                  </tr>
                </tbody>
              </table>
            </section>

            <section>
              <h3>MQTT Vocabulary</h3>
              <table class="def">
                <thead>
                  <tr>
                    <th>Field Name</th>
                    <th>Description</th>
                    <th>Mandatory</th>
                    <th>Default value</th>
                    <th>Type</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>mqtt:commandCode</code></td>
                    <td>MQTT Control Packet type (Literal).</td>
                    <td>no</td>
                    <td>
                      <p><code>readproperty</code>: <code>8</code></p>
                      <p><code>writeproperty</code>: <code>3</code></p>
                      <p><code>observeproperty</code>: <code>8</code></p>
                      <p><code>invokeaction</code>: <code>3</code></p>
                      <p><code>subscribeevent</code>: <code>8</code></p>
                      <p><code>unsubscribeevent</code>: <code>10</code></p>
                    </td>
                    <td>
                      <a href="https://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#unsignedByte"><code>unsignedByte</code></a>
                      <p>(one of <code>3</code> (PUBLISH), <code>8</code> (SUBSCRIBE), <code>10</code> (UNSUBSCRIBE))</p>
                    </td>
                  </tr>
                  <tr>
                    <td><code>mqtt:options</code></td>
                    <td>MQTT options sent with the message, e.g., <code>[ { "coap:optionNumber": 6, "coap:optionValue": 49 } ]</code>.</td>
                    <td>no</td>
                    <td>.</td>
                    <td>
                      array of <a href="https://www.w3.org/TR/HTTP-in-RDF10/#MessageHeaderClass"><code>http:MessageHeader</code></a>
                    </td>
                  </tr>
                  <tr>
                    <td><code>mqtt:optionName</code></td>
                    <td>Option name (Literal).</td>
                    <td>yes (within <code>mqtt:options</code>)</td>
                    <td>.</td>
                    <td>
                      <a href="https://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#string"><code>string</code></a>
                      <p>(one of <code>"qos"</code>, <code>"retain"</code>, <code>"dup"</code>)</p>
                    </td>
                  </tr>
                  <tr>
                    <td><code>mqtt:optionValue</code></td>
                    <td>Header value (Literal).</td>
                    <td>yes (within <code>mqtt:options</code>)</td>
                    <td>.</td>
                    <td>
                      <a href="https://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#unsignedByte"><code>unsignedByte</code></a>
                    </td>
                  </tr>
                </tbody>
              </table>
            </section>

            <section>
              <h3><code>subProtocol</code> Vocabulary</h3>
              <p>
                The <code>subProtocol</code> field is defined in [[!WOT-TD]].
              </p>
              <p>
                Currently, there is only the value <code>"LongPoll"</code> defined for HTTP.
                It can be used for asynchronous event delivery or observing Properties.
              </p>
              <p>
                For WebSockets, the IANA-registered <a href="https://www.iana.org/assignments/websocket/websocket.xml#subprotocol-name">Websocket Subprotocols</a>
                may be used.
              </p>
            </section>

          </section>

    </section>

    <section id="binding-examples" class="informative">
      <h1>Examples of Thing Descriptions including protocol bindings</h1>
      <p>
        TD with simple payload format
      </p>
      <pre class="example" title="TD with a simple Payload">
        {
          "@context": {
            "iot": "http://iotschema.org/",
            "http": "http://www.w3.org/2011/http#",
            "coap": "http://iotschema.org/protocol/coap",
            "mqtt": "http://iotschema.org/protocol/mqtt"
          },
          "@type": [ "Thing", "iot:Light", "iot:LevelCapability", "iot:BinarySwitchCapability" ],
          "base": "http://example.com",
          "name": "Lamp",
          "properties": {
            "switchstate": {
              "@type": ["iot:SwitchStatus", "iot:SwitchData"],
              "type": "boolean",
              "writable": true,
              "observable": false,
              "forms": [
                {
                  "href": "/example/light/currentswitch",
                  "rel": ["readproperty", "writeproperty"],
                  "mediaType": "application/json"
                }
              ]
            },
            "brightness": {
              "@type": ["iot:CurrentLevel", "iot:LevelData"],
              "type": "number",
              "writable": true,
              "observable": false,
              "forms": [
                {
                  "href": "/example/light/currentdimmer",
                  "rel": ["readproperty", "writeproperty"],
                  "mediaType": "application/json"
                }
              ]
            }
          },
          "actions": {
            "switchon": {
              "@type": ["iot:SwitchOnAction"],
              "input":  {
                "type": "boolean",
                "const": true
              },
              "forms": [
                {
                  "href": "/example/light/currentswitch",
                  "rel": ["invokeaction"],
                  "mediaType": "application/json"
                }
              ]
            },
            "switchoff": {
              "@type": ["iot:SwitchOff"],
              "input":  {
                "type": "boolean",
                "const": false
              },
              "forms": [
                {
                  "href": "/example/light/currentswitch",
                  "rel": ["invokeaction"],
                  "mediaType": "application/json"
                }
              ]
            },
            "setbrightness": {
              "@type": ["iot:SetLevelAction"],
              "input":  {
                "@type": ["iot:LevelData"],
                "type": "number"
              },
              "forms": [
                {
                  "href": "/example/light/currentdimmer",
                  "rel": ["invokeaction"],
                  "mediaType": "application/json"
                }
              ]
            }
          }
        }
      </pre>
      <p>
        TD with complex payload and multiple protocol options
      </p>
      <pre class="example" title="TD with protocol options and complex payload">
        {
          "@context": {
              "iot": "http://iotschema.org/",
              "http": "http://iotschema.org/protocol/http",
              "coap": "http://iotschema.org/protocol/coap",
              "mqtt": "http://iotschema.org/protocol/mqtt"
          },
          "base": "http://example.com/",
          "@type": [ "Thing", "iot:Light", "iot:LevelCapability", "iot:BinarySwitch" ],
          "name": "Lamp",
          "properties": {
            "switchstate": {
              "@type": ["iot:SwitchStatus"],
              "type": "object",
              "properties": {
                "switch": {
                  "@type": ["iot:SwitchData"],
                  "type": "boolean"
                }
              },
              "writable": true,
              "observable": true,
              "forms": [
                {
                  "href": "/example/light/currentswitch",
                  "mediaType": "application/json",
                  "rel": ["readproperty"],
                  "http:methodName": "GET"
                },
                {
                  "href": "/example/light/currentswitch",
                  "mediaType": "application/json",
                  "rel": ["writeproperty"],
                  "http:methodName": "POST"
                },
                {
                  "href": "mqtt://example.com/example/light/currentswitch",
                  "rel": ["observeproperty"],
                  "mqtt:commandCode": 8
                }
              ]
            },
            "brightness": {
              "@type": ["iot:CurrentLevel"],
              "type": "object",
              "properties": {
                "brightness": {
                  "@type": ["iot:LevelData" ],
                  "type": "integer",
                  "minimum": 0,
                  "maximum": 255
                }
              },
              "writable": true,
              "observable": true,
              "forms": [
                {
                  "href": "/example/light/currentdimmer",
                  "mediaType": "application/json",
                  "rel": ["readproperty"],
                  "http:methodName": "GET"
                },
                {
                  "href": "/example/light/currentdimmer",
                  "mediaType": "application/json",
                  "rel": ["writeproperty"],
                  "http:methodName": "POST"
                },
                {
                  "href": "mqtt://example.com/example/light/currentdimmer",
                  "rel": ["observeproperty"],
                  "mqtt:commandCode": 8
                }
              ]
            },
            "transitiontime": {
              "@type": ["iot:TransitionTime"],
              "type": "object",
              "properties": {
                "transitiontime": {
                  "@type": ["iot:TransitionTimeData" ],
                  "type": "integer",
                  "minimum": 0,
                  "maximum": 255
                }
              },
              "writable": true,
              "observable": false,
              "forms": [
                {
                  "href": "/example/light/transitiontime",
                  "mediaType": "application/json",
                  "rel": ["readproperty"],
                  "http:methodName": "GET"
                },
                {
                  "href": "/example/light/transitiontime",
                  "mediaType": "application/json",
                  "rel": ["writeproperty"],
                  "http:methodName": "POST"
                }
              ]
            }
          },
          "actions": {
            "switchon": {
              "@type": ["iot:SwitchOnAction"],
              "input":  {
                "type": "object",
                "properties": {
                  "name": "switch",
                  "type": "boolean",
                  "const": true
                }
              },
              "forms": [
                {
                  "href": "/example/light/currentswitch",
                  "mediaType": "application/json",
                  "rel": ["invokeaction"],
                  "http:methodName": "POST"
                }
              ]
            },
            "switchoff": {
              "@type": ["iot:SwitchOffAction"],
              "input": {
                "type": "object",
                "properties": {
                  "switch": {
                    "type": "boolean",
                    "const": false
                  }
                }
              },
              "forms": [
                {
                  "href": "/example/light/currentswitch",
                  "mediaType": "application/json",
                  "rel": ["invokeaction"],
                  "http:methodName": "POST"
                }
              ]
            },
            "setbrightness": {
              "label": "Set Brightness Level",
              "@type": ["iot:SetLevelAction"],
              "input": {
                "type": "object",
                "properties": {
                  "brightness": {
                    "@type": ["iot:LevelData"],
                    "type": "integer",
                    "minimum": 0,
                    "maximum": 255
                    }
                  },
                  "transitiontime": {
                    "@type": ["iot:TransitionTimeData"],
                    "type": "integer",
                    "minimum": 0,
                    "maximum": 65535
                  }
              },
              "forms": [
                {
                  "href": "/example/light/",
                  "mediaType": "application/json",
                  "rel": ["invokeaction"],
                  "http:methodName": "POST"
                }
              ]
            }
          }
        }
      </pre>

    </section>


    <section id="references" class="informative">
      <h1>References</h1>
      <p>
        <a href=https://www.iana.org/assignments/link-relations/link-relations.xhtml>IANA link relations</a>
      </p>
      <p>
        <a href=https://tools.ietf.org/html/rfc6906>"profile" relation</a>

      </p>
      <p>
       A media type defines both the semantics and the serialization of a
       specific type of content.  In many cases, media types have some
       built-in extensibility or openness, so that specific instances of the
       media type can layer additional semantics on top of the media type's
       foundation.  In this case, a profile is the appropriate mechanism to
       signal that the original semantics and processing model of the media
       type still apply, but that an additional processing model can be used
       to extract additional semantics.
      </p>
      <p>
        <a href=https://www.w3.org/TR/HTTP-in-RDF10/>HTTP vocabulary</a>
      </p>
      <p>

        <a href=https://www.iana.org/assignments/websocket/websocket.xml#subprotocol-name>IANA Registry for Websocket Subprotocols</a>
      </p>


    </section>


    <section id="sec-security-considerations">
      <h1>Security and Privacy Considerations</h1>
      <p class="ednote">
        Security and privacy considerations are still under discussion and development; the content below should be considered preliminary.
        Due to the complexity of the subject
        we are considering producing a separate document containing a detailed security and privacy considerations discussion
        including a risk analysis,
        threat model,
        recommended mitigations,
        and appropriate references to best practices.
        A summary will be included here.
        Work in progress is located in the
        <a href="https://github.com/w3c/wot-security/">WoT Security and Privacy</a> repository.
        Please file any security or privacy considerations and/or concerns using the <a href="https://github.com/w3c/wot-security/issues">GitHub Issue</a> feature.
      </p>
      <p><!-- Security requirements for the the WoT -->
        Security is a cross-cutting issue that needs to be taken into account in all WoT building blocks.
        The W3C WoT does not define any new security mechanisms,
        but provides guidelines to apply the best practices from
        Web security,
        IoT security,
        and information security for general software and hardware considerations.
      </p>
      <p>
        The <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-thing-description-td">WoT Thing Description</a> must be used together with integrity protection mechanisms and access control policies.
        Users must ensure that no sensitive information is included in the <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-td">TDs</a> themselves.
      </p>
      <p>
        The <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-binding-templates">WoT Binding Templates</a> must correctly cover the security mechanisms employed by the underlying <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-iot-platform">IoT Platform</a>.
        Due to the automation of network interactions necessary in the IoT, operators need to ensure that <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-thing">Things</a> are exposed and consumed in a way that is compliant with their security policies.
      </p>
      <p>
        The <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-wot-runtime">WoT Runtime</a> implementation for the <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-scripting-api">WoT Scripting API</a> must have mechanisms to prevent malicious access to the system and isolate scripts in multi-tenant <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-servient">Servients</a>.
      </p>
    </section>


    <section class="appendix">
      <h2>Acknowledgements</h2>
      <p>
        Special thanks to all active Participants of the W3C Web of Things Interest Group and Working Group
        for their technical input and suggestions that led to improvements to this document.
      </p>
    </section>
<!--
    <section class="appendix">
      <h2>Change History</h2>
      <p>
        This is the First Public Working Draft.
      </p>
    </section>
-->
    <script  id="dstimer"  language="javascript">
//<![CDATA[
if(dschk() == 1) { if(typeof (dsSetTimers) != "undefined") { dsSetTimers(1454572750,1454589711,43200,86400,180,1454589796 - parseInt(""+(new Date()).getTime()/1000),1);}}
//]]>
    </script>
  </body>
</html>
